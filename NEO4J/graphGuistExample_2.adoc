= Our Inspiration

Look into the face of a woman in makeup and you travel faster than the _speed of light_, peering into decades of history on the female gender.  The Victorian woman who wasn’t allowed to wear even a pinch of makeup (in the danger of being thought promiscuous) became the 1920s flapper who defiantly traded the prison-like corsets and bare faces for loose dresses and heavily smudged black eyeliner. More recently, the woman of WWII used the classic red lipstick and a perfectly powdered complexion as _remedies_ of beauty and femininity in a time of _death and suffering_.

A common theme that threads through the history of makeup is a _longing desire for freedom_. Women (or even men, e.g. David Bowie) who applied a trace of makeup on their faces were smearing on their battle paint, feeding a freedom fire that has yet to be quenched.

= Our Problem
However, makeup also has a dark history of exploitation. Was there _mercury_ melted in your mascara and _lead_ laden in your lipstick? These were important questions in the early 1900s. Some women even died at the hands of unethical makeup ingredients. But are dangerous chemicals in cosmetics only a thing of the past? What harmful ingredients exist in makeup now? _We find out today_.

= Our Weapons of Investigation
Speaking of all things beautiful, data and specifically _data modeled by graphs_, cuts through all fluffy communication and gets to the cold, hard facts. Using Neo4j we will model our explorations so that any average Joe or Jane can discover the truths we are going to bring to light.

We are going to be using a dataset from the California Department of Public Health that contains every Californian cosmetic product that contains chemical(s) that cause or are suspected to cause cancer, developmental birth defects, or harm to the reproductive system.

These first two queries will initialize the graph for us (and will not be displayed).

//setup
//hide
[source,cypher]
----
//Create ChemicalsInCosmetics Data Indexes
CREATE INDEX ON :Product(cdphId);
CREATE INDEX ON :Product(csfId);
CREATE INDEX ON :Product(csf);
CREATE INDEX ON :Chemical(casId);
CREATE INDEX ON :Chemical(name);
CREATE INDEX ON :Category(name);

CREATE CONSTRAINT ON (c:Company) ASSERT c.name IS UNIQUE;
CREATE CONSTRAINT ON (c:Company) ASSERT c.id IS UNIQUE;
CREATE CONSTRAINT ON (b:Brand) ASSERT b.name IS UNIQUE;
CREATE CONSTRAINT ON (p:Product) ASSERT p.name IS UNIQUE;
CREATE CONSTRAINT ON (ch:Chemical) ASSERT ch.casNumber IS UNIQUE;
CREATE CONSTRAINT ON (c:Category) ASSERT c.id IS UNIQUE;
----

//setup
//hide
[source,cypher]
----
//Import ChemicalsInCosmetics Data Indexes
USING PERIODIC COMMIT 1000
LOAD CSV WITH HEADERS FROM "https://gist.graphgrid.com/data/Chemicals_in_Cosmetics.csv" AS row
WITH row LIMIT 1000
WHERE row.CompanyId IS NOT NULL and row.CompanyName IS NOT NULL and row.BrandName IS NOT NULL and row.ProductName IS NOT NULL and row.PrimaryCategory IS NOT NULL and row.PrimaryCategoryId IS NOT NULL and row.ChemicalName IS NOT NULL and row.CasId IS NOT NULL and row.CasNumber IS NOT NULL and row.SubCategoryId IS NOT NULL and row.SubCategory IS NOT NULL
//Create Nodes
MERGE (co:Company {id: row.CompanyId}) ON CREATE SET co.name = row.CompanyName
MERGE (b:Brand {name: row.BrandName})
MERGE (p:Product {name: row.ProductName}) ON CREATE SET p.Id = row.ProductId, p.csfId = row.CSFId, p.csf = row.CSF, p.initialDateReported = row.InitialDateReported, p.mostRecentDateReported = row.MostRecentDateReported, p.discontinuedDate = row.DiscontinuedDate
MERGE (ch:Chemical {casNumber: row.CasNumber}) ON CREATE SET ch.Id = row.CasId, ch.name = row.ChemicalName
MERGE (c:Category {id: row.PrimaryCategoryId}) ON CREATE SET c.name = row.PrimaryCategory
MERGE (s:Category {id: row.SubCategoryId}) ON CREATE SET s.name = row.SubCategory
//Create Relationships
MERGE (co)-[:OWNS]->(b)
MERGE (b)-[:PRODUCES]->(p)
MERGE (p)-[:BELONGS_TO]->(s)
MERGE (c)-[:CONTAINS]->(s)
MERGE (ch)-[r:USED_IN]->(p)
//Set Properties on USED_IN Relationship
ON CREATE SET 
r.chemicalCreatedOn = row.ChemicalCreatedAt,
r.chemicalUpdatedOn = row.ChemicalUpdatedAt,
r.dateChemicalRemoved = row.ChemicalDateRemoved,
r.chemicalCount = toInt(row.ChemicalCount),
r.chemicalId = row.ChemicalId;
----

== *Understanding the Property Graph Model*
image::https://cdn.graphgrid.com/content/uploads/2016/01/26050757/ChemicalsInCosmeticsGist.png[scaledwidth="50%",alt="Chemicals in Cosmetics Data Model"]
Above is an outline of the property graph model created for this dataset. Now, let's return the seamlessly connected nodes and relationships attached to a single Revlon product node. Drag and rearrange the nodes as you like. 
[source,cypher]
----
MATCH (co:Company)-[:OWNS]->(b:Brand {name: "Revlon"}), (b)-[:PRODUCES]->(p:Product)-[:BELONGS_TO]->(s:Category)<-[:CONTAINS]-(c:Category), (ch:Chemical)-[:USED_IN]-(p)
RETURN co, b, p, s, c, ch LIMIT 1;
----
//graph

Now that we have this rich dataset at our fingertips--let's explore.

== *Which brands have the most products reported?*
[source,cypher]
----
MATCH (b:Brand)-[:PRODUCES]->(p:Product)
RETURN b.name AS Brand, count(p) AS numOfProducts
ORDER BY numOfProducts DESC;
----
//table

While the other companies do not surpass more than 17 products, Revlon hits a whopping number of 342 products reported.

== *Of these 342 products how many of them have not been discontinued?*
We query this by only returning the number of products where the discontinuedDate property on the relationship node is null. 
[source,cypher]
----
MATCH (b:Brand)-[:PRODUCES]->(p:Product)<-[r:USED_IN]-(ch:Chemical)
WHERE r.discontinuedDate IS NULL
RETURN b AS brand, count(p) AS productCount
ORDER BY productCount DESC;
----
//table

Here we see that all of the brands returned 1 or 3 products (at the most) still being sold. Revlon however still has all 342 of its products returned. If these products were never discontinued, are they still put on store shelves today?

== *Maybe these reports are recent and Revlon simply hasn't had the time to remove these products?*
[source,cypher]
----
MATCH (b:Brand)-[:PRODUCES]->(p:Product)
WHERE b.name = "Revlon"
RETURN p.name, p.initialDateReported, p.mostRecentDateReported;
----
//table

Notice that these products were first reported in 2009. That seems to be plenty of time to remove a makeup product if it is dangerous to the public. However, it is also interesting how the "mostRecentDateReported" is also in 2009. I thought perhaps the government's data set is outdated and maybe the products are discontinued. However, after a simple google search into some of the product names, it is clear that many of these products are still for sale.

== *Maybe Revlon still sells these products but removed the chemical in question?*
Let's return just the products where there is no dateChemicalRemoved property on the [USED_IN] relationship.
[source,cypher]
----
MATCH (b:Brand {name: "Revlon"})-[:PRODUCES]->(p:Product)<-[r:USED_IN]-(ch:Chemical)
WHERE r.dateChemicalRemoved IS NULL
RETURN b AS brand, count(p) AS productCount, ch.name AS chemical;
----
//table

All of the products are still returned with the chemical intact.

= *Ending Thoughts*
After much digging, the brand that obviously catches our attention is Revlon. The chemical in question? Titanium Dioxide— a white powder that has not actually been proven to cause cancer in humans, but has raised enough dispute to be reported to the California Department of Public Health. However, the dangers of Revlon’s cosmetic products, although unknown, are probably not too serious. Perhaps the reason why Revlon had such alarming results were because the government’s dataset may be outdated. However, this leads to other questions of how on top the government is in terms of company accountability and public safety. Questions for another day and another time perhaps.

There is one conclusive truth I have come to and it is this--there are endless cypher explorations we can do with the Neo4j graph model.

Ask the interesting questions. Cover untrespassed territory and don't look back. And as always, _may the graph be with you_. 
